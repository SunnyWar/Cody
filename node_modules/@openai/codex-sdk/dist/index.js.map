{"version":3,"sources":["../src/outputSchemaFile.ts","../src/thread.ts","../src/exec.ts","../src/codex.ts"],"sourcesContent":["import { promises as fs } from \"node:fs\";\nimport os from \"node:os\";\nimport path from \"node:path\";\n\nexport type OutputSchemaFile = {\n  schemaPath?: string;\n  cleanup: () => Promise<void>;\n};\n\nexport async function createOutputSchemaFile(schema: unknown): Promise<OutputSchemaFile> {\n  if (schema === undefined) {\n    return { cleanup: async () => {} };\n  }\n\n  if (!isJsonObject(schema)) {\n    throw new Error(\"outputSchema must be a plain JSON object\");\n  }\n\n  const schemaDir = await fs.mkdtemp(path.join(os.tmpdir(), \"codex-output-schema-\"));\n  const schemaPath = path.join(schemaDir, \"schema.json\");\n  const cleanup = async () => {\n    try {\n      await fs.rm(schemaDir, { recursive: true, force: true });\n    } catch {\n      // suppress\n    }\n  };\n\n  try {\n    await fs.writeFile(schemaPath, JSON.stringify(schema), \"utf8\");\n    return { schemaPath, cleanup };\n  } catch (error) {\n    await cleanup();\n    throw error;\n  }\n}\n\nfunction isJsonObject(value: unknown): value is Record<string, unknown> {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n","import { CodexOptions } from \"./codexOptions\";\nimport { ThreadEvent, ThreadError, Usage } from \"./events\";\nimport { CodexExec } from \"./exec\";\nimport { ThreadItem } from \"./items\";\nimport { ThreadOptions } from \"./threadOptions\";\nimport { TurnOptions } from \"./turnOptions\";\nimport { createOutputSchemaFile } from \"./outputSchemaFile\";\n\n/** Completed turn. */\nexport type Turn = {\n  items: ThreadItem[];\n  finalResponse: string;\n  usage: Usage | null;\n};\n\n/** Alias for `Turn` to describe the result of `run()`. */\nexport type RunResult = Turn;\n\n/** The result of the `runStreamed` method. */\nexport type StreamedTurn = {\n  events: AsyncGenerator<ThreadEvent>;\n};\n\n/** Alias for `StreamedTurn` to describe the result of `runStreamed()`. */\nexport type RunStreamedResult = StreamedTurn;\n\n/** An input to send to the agent. */\nexport type UserInput =\n  | {\n      type: \"text\";\n      text: string;\n    }\n  | {\n      type: \"local_image\";\n      path: string;\n    };\n\nexport type Input = string | UserInput[];\n\n/** Represent a thread of conversation with the agent. One thread can have multiple consecutive turns. */\nexport class Thread {\n  private _exec: CodexExec;\n  private _options: CodexOptions;\n  private _id: string | null;\n  private _threadOptions: ThreadOptions;\n\n  /** Returns the ID of the thread. Populated after the first turn starts. */\n  public get id(): string | null {\n    return this._id;\n  }\n\n  /* @internal */\n  constructor(\n    exec: CodexExec,\n    options: CodexOptions,\n    threadOptions: ThreadOptions,\n    id: string | null = null,\n  ) {\n    this._exec = exec;\n    this._options = options;\n    this._id = id;\n    this._threadOptions = threadOptions;\n  }\n\n  /** Provides the input to the agent and streams events as they are produced during the turn. */\n  async runStreamed(input: Input, turnOptions: TurnOptions = {}): Promise<StreamedTurn> {\n    return { events: this.runStreamedInternal(input, turnOptions) };\n  }\n\n  private async *runStreamedInternal(\n    input: Input,\n    turnOptions: TurnOptions = {},\n  ): AsyncGenerator<ThreadEvent> {\n    const { schemaPath, cleanup } = await createOutputSchemaFile(turnOptions.outputSchema);\n    const options = this._threadOptions;\n    const { prompt, images } = normalizeInput(input);\n    const generator = this._exec.run({\n      input: prompt,\n      baseUrl: this._options.baseUrl,\n      apiKey: this._options.apiKey,\n      threadId: this._id,\n      images,\n      model: options?.model,\n      sandboxMode: options?.sandboxMode,\n      workingDirectory: options?.workingDirectory,\n      skipGitRepoCheck: options?.skipGitRepoCheck,\n      outputSchemaFile: schemaPath,\n      modelReasoningEffort: options?.modelReasoningEffort,\n      signal: turnOptions.signal,\n      networkAccessEnabled: options?.networkAccessEnabled,\n      webSearchMode: options?.webSearchMode,\n      webSearchEnabled: options?.webSearchEnabled,\n      approvalPolicy: options?.approvalPolicy,\n      additionalDirectories: options?.additionalDirectories,\n    });\n    try {\n      for await (const item of generator) {\n        let parsed: ThreadEvent;\n        try {\n          parsed = JSON.parse(item) as ThreadEvent;\n        } catch (error) {\n          throw new Error(`Failed to parse item: ${item}`, { cause: error });\n        }\n        if (parsed.type === \"thread.started\") {\n          this._id = parsed.thread_id;\n        }\n        yield parsed;\n      }\n    } finally {\n      await cleanup();\n    }\n  }\n\n  /** Provides the input to the agent and returns the completed turn. */\n  async run(input: Input, turnOptions: TurnOptions = {}): Promise<Turn> {\n    const generator = this.runStreamedInternal(input, turnOptions);\n    const items: ThreadItem[] = [];\n    let finalResponse: string = \"\";\n    let usage: Usage | null = null;\n    let turnFailure: ThreadError | null = null;\n    for await (const event of generator) {\n      if (event.type === \"item.completed\") {\n        if (event.item.type === \"agent_message\") {\n          finalResponse = event.item.text;\n        }\n        items.push(event.item);\n      } else if (event.type === \"turn.completed\") {\n        usage = event.usage;\n      } else if (event.type === \"turn.failed\") {\n        turnFailure = event.error;\n        break;\n      }\n    }\n    if (turnFailure) {\n      throw new Error(turnFailure.message);\n    }\n    return { items, finalResponse, usage };\n  }\n}\n\nfunction normalizeInput(input: Input): { prompt: string; images: string[] } {\n  if (typeof input === \"string\") {\n    return { prompt: input, images: [] };\n  }\n  const promptParts: string[] = [];\n  const images: string[] = [];\n  for (const item of input) {\n    if (item.type === \"text\") {\n      promptParts.push(item.text);\n    } else if (item.type === \"local_image\") {\n      images.push(item.path);\n    }\n  }\n  return { prompt: promptParts.join(\"\\n\\n\"), images };\n}\n","import { spawn } from \"node:child_process\";\nimport path from \"node:path\";\nimport readline from \"node:readline\";\nimport { createRequire } from \"node:module\";\n\nimport type { CodexConfigObject, CodexConfigValue } from \"./codexOptions\";\nimport { SandboxMode, ModelReasoningEffort, ApprovalMode, WebSearchMode } from \"./threadOptions\";\n\nexport type CodexExecArgs = {\n  input: string;\n\n  baseUrl?: string;\n  apiKey?: string;\n  threadId?: string | null;\n  images?: string[];\n  // --model\n  model?: string;\n  // --sandbox\n  sandboxMode?: SandboxMode;\n  // --cd\n  workingDirectory?: string;\n  // --add-dir\n  additionalDirectories?: string[];\n  // --skip-git-repo-check\n  skipGitRepoCheck?: boolean;\n  // --output-schema\n  outputSchemaFile?: string;\n  // --config model_reasoning_effort\n  modelReasoningEffort?: ModelReasoningEffort;\n  // AbortSignal to cancel the execution\n  signal?: AbortSignal;\n  // --config sandbox_workspace_write.network_access\n  networkAccessEnabled?: boolean;\n  // --config web_search\n  webSearchMode?: WebSearchMode;\n  // legacy --config features.web_search_request\n  webSearchEnabled?: boolean;\n  // --config approval_policy\n  approvalPolicy?: ApprovalMode;\n};\n\nconst INTERNAL_ORIGINATOR_ENV = \"CODEX_INTERNAL_ORIGINATOR_OVERRIDE\";\nconst TYPESCRIPT_SDK_ORIGINATOR = \"codex_sdk_ts\";\nconst CODEX_NPM_NAME = \"@openai/codex\";\n\nconst PLATFORM_PACKAGE_BY_TARGET: Record<string, string> = {\n  \"x86_64-unknown-linux-musl\": \"@openai/codex-linux-x64\",\n  \"aarch64-unknown-linux-musl\": \"@openai/codex-linux-arm64\",\n  \"x86_64-apple-darwin\": \"@openai/codex-darwin-x64\",\n  \"aarch64-apple-darwin\": \"@openai/codex-darwin-arm64\",\n  \"x86_64-pc-windows-msvc\": \"@openai/codex-win32-x64\",\n  \"aarch64-pc-windows-msvc\": \"@openai/codex-win32-arm64\",\n};\n\nconst moduleRequire = createRequire(import.meta.url);\n\nexport class CodexExec {\n  private executablePath: string;\n  private envOverride?: Record<string, string>;\n  private configOverrides?: CodexConfigObject;\n\n  constructor(\n    executablePath: string | null = null,\n    env?: Record<string, string>,\n    configOverrides?: CodexConfigObject,\n  ) {\n    this.executablePath = executablePath || findCodexPath();\n    this.envOverride = env;\n    this.configOverrides = configOverrides;\n  }\n\n  async *run(args: CodexExecArgs): AsyncGenerator<string> {\n    const commandArgs: string[] = [\"exec\", \"--experimental-json\"];\n\n    if (this.configOverrides) {\n      for (const override of serializeConfigOverrides(this.configOverrides)) {\n        commandArgs.push(\"--config\", override);\n      }\n    }\n\n    if (args.model) {\n      commandArgs.push(\"--model\", args.model);\n    }\n\n    if (args.sandboxMode) {\n      commandArgs.push(\"--sandbox\", args.sandboxMode);\n    }\n\n    if (args.workingDirectory) {\n      commandArgs.push(\"--cd\", args.workingDirectory);\n    }\n\n    if (args.additionalDirectories?.length) {\n      for (const dir of args.additionalDirectories) {\n        commandArgs.push(\"--add-dir\", dir);\n      }\n    }\n\n    if (args.skipGitRepoCheck) {\n      commandArgs.push(\"--skip-git-repo-check\");\n    }\n\n    if (args.outputSchemaFile) {\n      commandArgs.push(\"--output-schema\", args.outputSchemaFile);\n    }\n\n    if (args.modelReasoningEffort) {\n      commandArgs.push(\"--config\", `model_reasoning_effort=\"${args.modelReasoningEffort}\"`);\n    }\n\n    if (args.networkAccessEnabled !== undefined) {\n      commandArgs.push(\n        \"--config\",\n        `sandbox_workspace_write.network_access=${args.networkAccessEnabled}`,\n      );\n    }\n\n    if (args.webSearchMode) {\n      commandArgs.push(\"--config\", `web_search=\"${args.webSearchMode}\"`);\n    } else if (args.webSearchEnabled === true) {\n      commandArgs.push(\"--config\", `web_search=\"live\"`);\n    } else if (args.webSearchEnabled === false) {\n      commandArgs.push(\"--config\", `web_search=\"disabled\"`);\n    }\n\n    if (args.approvalPolicy) {\n      commandArgs.push(\"--config\", `approval_policy=\"${args.approvalPolicy}\"`);\n    }\n\n    if (args.threadId) {\n      commandArgs.push(\"resume\", args.threadId);\n    }\n\n    if (args.images?.length) {\n      for (const image of args.images) {\n        commandArgs.push(\"--image\", image);\n      }\n    }\n\n    const env: Record<string, string> = {};\n    if (this.envOverride) {\n      Object.assign(env, this.envOverride);\n    } else {\n      for (const [key, value] of Object.entries(process.env)) {\n        if (value !== undefined) {\n          env[key] = value;\n        }\n      }\n    }\n    if (!env[INTERNAL_ORIGINATOR_ENV]) {\n      env[INTERNAL_ORIGINATOR_ENV] = TYPESCRIPT_SDK_ORIGINATOR;\n    }\n    if (args.baseUrl) {\n      env.OPENAI_BASE_URL = args.baseUrl;\n    }\n    if (args.apiKey) {\n      env.CODEX_API_KEY = args.apiKey;\n    }\n\n    const child = spawn(this.executablePath, commandArgs, {\n      env,\n      signal: args.signal,\n    });\n\n    let spawnError: unknown | null = null;\n    child.once(\"error\", (err) => (spawnError = err));\n\n    if (!child.stdin) {\n      child.kill();\n      throw new Error(\"Child process has no stdin\");\n    }\n    child.stdin.write(args.input);\n    child.stdin.end();\n\n    if (!child.stdout) {\n      child.kill();\n      throw new Error(\"Child process has no stdout\");\n    }\n    const stderrChunks: Buffer[] = [];\n\n    if (child.stderr) {\n      child.stderr.on(\"data\", (data) => {\n        stderrChunks.push(data);\n      });\n    }\n\n    const exitPromise = new Promise<{ code: number | null; signal: NodeJS.Signals | null }>(\n      (resolve) => {\n        child.once(\"exit\", (code, signal) => {\n          resolve({ code, signal });\n        });\n      },\n    );\n\n    const rl = readline.createInterface({\n      input: child.stdout,\n      crlfDelay: Infinity,\n    });\n\n    try {\n      for await (const line of rl) {\n        // `line` is a string (Node sets default encoding to utf8 for readline)\n        yield line as string;\n      }\n\n      if (spawnError) throw spawnError;\n      const { code, signal } = await exitPromise;\n      if (code !== 0 || signal) {\n        const stderrBuffer = Buffer.concat(stderrChunks);\n        const detail = signal ? `signal ${signal}` : `code ${code ?? 1}`;\n        throw new Error(`Codex Exec exited with ${detail}: ${stderrBuffer.toString(\"utf8\")}`);\n      }\n    } finally {\n      rl.close();\n      child.removeAllListeners();\n      try {\n        if (!child.killed) child.kill();\n      } catch {\n        // ignore\n      }\n    }\n  }\n}\n\nfunction serializeConfigOverrides(configOverrides: CodexConfigObject): string[] {\n  const overrides: string[] = [];\n  flattenConfigOverrides(configOverrides, \"\", overrides);\n  return overrides;\n}\n\nfunction flattenConfigOverrides(\n  value: CodexConfigValue,\n  prefix: string,\n  overrides: string[],\n): void {\n  if (!isPlainObject(value)) {\n    if (prefix) {\n      overrides.push(`${prefix}=${toTomlValue(value, prefix)}`);\n      return;\n    } else {\n      throw new Error(\"Codex config overrides must be a plain object\");\n    }\n  }\n\n  const entries = Object.entries(value);\n  if (!prefix && entries.length === 0) {\n    return;\n  }\n\n  if (prefix && entries.length === 0) {\n    overrides.push(`${prefix}={}`);\n    return;\n  }\n\n  for (const [key, child] of entries) {\n    if (!key) {\n      throw new Error(\"Codex config override keys must be non-empty strings\");\n    }\n    if (child === undefined) {\n      continue;\n    }\n    const path = prefix ? `${prefix}.${key}` : key;\n    if (isPlainObject(child)) {\n      flattenConfigOverrides(child, path, overrides);\n    } else {\n      overrides.push(`${path}=${toTomlValue(child, path)}`);\n    }\n  }\n}\n\nfunction toTomlValue(value: CodexConfigValue, path: string): string {\n  if (typeof value === \"string\") {\n    return JSON.stringify(value);\n  } else if (typeof value === \"number\") {\n    if (!Number.isFinite(value)) {\n      throw new Error(`Codex config override at ${path} must be a finite number`);\n    }\n    return `${value}`;\n  } else if (typeof value === \"boolean\") {\n    return value ? \"true\" : \"false\";\n  } else if (Array.isArray(value)) {\n    const rendered = value.map((item, index) => toTomlValue(item, `${path}[${index}]`));\n    return `[${rendered.join(\", \")}]`;\n  } else if (isPlainObject(value)) {\n    const parts: string[] = [];\n    for (const [key, child] of Object.entries(value)) {\n      if (!key) {\n        throw new Error(\"Codex config override keys must be non-empty strings\");\n      }\n      if (child === undefined) {\n        continue;\n      }\n      parts.push(`${formatTomlKey(key)} = ${toTomlValue(child, `${path}.${key}`)}`);\n    }\n    return `{${parts.join(\", \")}}`;\n  } else if (value === null) {\n    throw new Error(`Codex config override at ${path} cannot be null`);\n  } else {\n    const typeName = typeof value;\n    throw new Error(`Unsupported Codex config override value at ${path}: ${typeName}`);\n  }\n}\n\nconst TOML_BARE_KEY = /^[A-Za-z0-9_-]+$/;\nfunction formatTomlKey(key: string): string {\n  return TOML_BARE_KEY.test(key) ? key : JSON.stringify(key);\n}\n\nfunction isPlainObject(value: unknown): value is CodexConfigObject {\n  return typeof value === \"object\" && value !== null && !Array.isArray(value);\n}\n\nfunction findCodexPath() {\n  const { platform, arch } = process;\n\n  let targetTriple = null;\n  switch (platform) {\n    case \"linux\":\n    case \"android\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-unknown-linux-musl\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-unknown-linux-musl\";\n          break;\n        default:\n          break;\n      }\n      break;\n    case \"darwin\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-apple-darwin\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-apple-darwin\";\n          break;\n        default:\n          break;\n      }\n      break;\n    case \"win32\":\n      switch (arch) {\n        case \"x64\":\n          targetTriple = \"x86_64-pc-windows-msvc\";\n          break;\n        case \"arm64\":\n          targetTriple = \"aarch64-pc-windows-msvc\";\n          break;\n        default:\n          break;\n      }\n      break;\n    default:\n      break;\n  }\n\n  if (!targetTriple) {\n    throw new Error(`Unsupported platform: ${platform} (${arch})`);\n  }\n\n  const platformPackage = PLATFORM_PACKAGE_BY_TARGET[targetTriple];\n  if (!platformPackage) {\n    throw new Error(`Unsupported target triple: ${targetTriple}`);\n  }\n\n  let vendorRoot: string;\n  try {\n    const codexPackageJsonPath = moduleRequire.resolve(`${CODEX_NPM_NAME}/package.json`);\n    const codexRequire = createRequire(codexPackageJsonPath);\n    const platformPackageJsonPath = codexRequire.resolve(`${platformPackage}/package.json`);\n    vendorRoot = path.join(path.dirname(platformPackageJsonPath), \"vendor\");\n  } catch {\n    throw new Error(\n      `Unable to locate Codex CLI binaries. Ensure ${CODEX_NPM_NAME} is installed with optional dependencies.`,\n    );\n  }\n\n  const archRoot = path.join(vendorRoot, targetTriple);\n  const codexBinaryName = process.platform === \"win32\" ? \"codex.exe\" : \"codex\";\n  const binaryPath = path.join(archRoot, \"codex\", codexBinaryName);\n\n  return binaryPath;\n}\n","import { CodexOptions } from \"./codexOptions\";\nimport { CodexExec } from \"./exec\";\nimport { Thread } from \"./thread\";\nimport { ThreadOptions } from \"./threadOptions\";\n\n/**\n * Codex is the main class for interacting with the Codex agent.\n *\n * Use the `startThread()` method to start a new thread or `resumeThread()` to resume a previously started thread.\n */\nexport class Codex {\n  private exec: CodexExec;\n  private options: CodexOptions;\n\n  constructor(options: CodexOptions = {}) {\n    const { codexPathOverride, env, config } = options;\n    this.exec = new CodexExec(codexPathOverride, env, config);\n    this.options = options;\n  }\n\n  /**\n   * Starts a new conversation with an agent.\n   * @returns A new thread instance.\n   */\n  startThread(options: ThreadOptions = {}): Thread {\n    return new Thread(this.exec, this.options, options);\n  }\n\n  /**\n   * Resumes a conversation with an agent based on the thread id.\n   * Threads are persisted in ~/.codex/sessions.\n   *\n   * @param id The id of the thread to resume.\n   * @returns A new thread instance.\n   */\n  resumeThread(id: string, options: ThreadOptions = {}): Thread {\n    return new Thread(this.exec, this.options, options, id);\n  }\n}\n"],"mappings":"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","names":["path"]}